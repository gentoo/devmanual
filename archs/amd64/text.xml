<?xml version="1.0" encoding="UTF-8"?>
<devbook self="archs/amd64/">
<chapter>
<title>Arch specific notes â€” AMD64/EM64T</title>

<section>
<title>Position Independent Code issues</title>
<body>

<p>
Gentoo Policy demands all shared objects to be compiled with <c>-fPIC</c>
in <c>CFLAGS</c>. Since this is only a rule, you <e>can</e> break it on some arches.
You might never notice it. On AMD64, this is a necessity, if shared objects aren't
built with support for position independent code, the build process bails out
with an error message like this:
</p>

<pre>
foo.o: relocation R_X86_64_32 can not be used when making a shared
object; recompile with -fPIC
</pre>
</body>

<subsection>
<title>How to fix -fPIC issues</title>
<body>

<p>
There are several ways to enforce <c>-fPIC</c> on shared objects, each with its
pros and cons.
</p>
</body>

<subsubsection>
<title><c>sed</c>'ing the Makefile</title>
<body>

<p>
Sometimes, a simple <c>sed</c> command is enough to fix it, however, the statements
normally aren't very readable and may fail when upstream changes the file.
Please verify that you only change the <c>CFLAGS</c> for <e>shared</e> objects, not for
the whole package.
</p>

</body>
</subsubsection>

<subsubsection>
<title>Patching <c>Makefile.in</c>/<c>configure</c></title>
<body>

<p>
This is more readable, and easier to send upstream.
</p>

</body>
</subsubsection>
</subsection>

<subsection>
<title>How <b>not</b> to fix -fPIC issues</title>
<body>

<p>
Do <b>not</b> patch the <c>Makefile</c> itself, since it is usually generated by the
<c>configure</c> script and may vary heavily, so the patch could fail. Also, this
doesn't help upstream at all.
</p>

<p>
Another bad idea is to (ab)use <c>append-flags</c> function from
<c><uri link="::eclass-reference/flag-o-matic.eclass/"/></c>.
Applying <c>-fPIC</c> on all objects should not be done. It should only be
applied to shared objects.
</p>

</body>
</subsection>
</section>

<section>
<title>Multilib on AMD64</title>
<body>

<p>
The current AMD64 processors are able to natively run 32-bit code on a 64-bit
kernel. Therefore, you can run programs compiled for x86 in an amd64 environment.
However, 32-bit applications need to be linked against 32-bit libraries. Mixing
them won't work. For this reason the libraries are sorted, 32-bit libraries
normally go to <c>/lib32</c> respectively <c>/usr/lib32</c>, the 64-bit ones
normally to <c>/lib64</c> or <c>/usr/lib64</c>. In a perfect world, you wouldn't
have to read on. Unfortunately, that's not the case, and so it's a bit more
complicated.
</p>
</body>

<subsection>
<title>Multilib toolchain</title>

<subsubsection>
<title>GCC</title>
<body>

<p>
To generate 32-bit code, we need a multilib-capable GCC. On other architectures,
this functionality is enabled with the USE flag <c>multilib</c>. This is also true
for amd64 with the <e>pre</e>-2005.0 profiles. From 2005.0 on, you have to choose
whether you want multilib support or not by selecting the profile. Choose
<c>2005.0/no-multilib</c> if you don't want it, all other profiles have the
<c>multilib</c> USE flag masked, you're forced to it. With these profiles, GCC will
produce x86-code whenever you add <c>-m32</c> to its command line. Adding <c>-m64</c>
or omitting any bit-width option will default to producing 64-bit code.
</p>

</body>
</subsubsection>

<subsubsection>
<title>glibc</title>
<body>

<p>
If you've chosen a multilib profile, glibc will be built twice, once 64-bit and
once 32-bit. This is because nearly every application links against glibc.
To understand how this is done in the ebuild, read
<uri link="::archs/amd64/#The ABI variable"/>.
</p>

</body>
</subsubsection>
</subsection>

<subsection>
<title>32-bit compatibility</title>
<body>

<p>
As you read above, 32-bit applications must be linked against 32-bit libraries.
For that, we've made the most common libraries as multilib (via <c>ABI</c>
variable and <c><uri link="::eclass-reference/multilib.eclass/"/></c>).
</p>

</body>
</subsection>

<subsection>
<title>Libdir links</title>
<body>

<p>
Currently, we provide several profiles, each with its own combination of
<c>libdir</c> configurations. Table entries x86, amd64, etc. indicate that
the directory contains objects for this ABI; entries with an arrow indicate
a symlink to the respective directory.
</p>

<table>
  <tr>
    <th>Profile</th>
    <th>lib</th>
    <th>lib32</th>
    <th>lib64</th>
    <th>libx32</th>
  </tr>
  <tr>
    <ti>17.0</ti>
    <ti>-&gt; lib64</ti>
    <ti>x86</ti>
    <ti>amd64</ti>
    <ti>non-existent</ti>
  </tr>
  <tr>
    <ti>17.0/no-multilib</ti>
    <ti>-&gt; lib64</ti>
    <ti>non-existent</ti>
    <ti>amd64</ti>
    <ti>non-existent</ti>
  </tr>
  <tr>
    <ti>17.0/x32</ti>
    <ti>-&gt; libx32</ti>
    <ti>x86</ti>
    <ti>amd64</ti>
    <ti>x32</ti>
  </tr>
  <tr>
    <ti>17.1</ti>
    <ti>x86</ti>
    <ti>non-existent</ti>
    <ti>amd64</ti>
    <ti>non-existent</ti>
  </tr>
  <tr>
    <ti>17.1/no-multilib</ti>
    <ti>n/a</ti>
    <ti>non-existent</ti>
    <ti>amd64</ti>
    <ti>non-existent</ti>
  </tr>
</table>

<p>
To always get the right path, you should use <c>$(get_libdir)</c> which is
available as a package manager function since EAPI 6. It will always return
the correct directory, on all arches. And of course it also takes care of
the <c>ABI</c> variable.
</p>

</body>
</subsection>

<subsection>
<title>The <c>multilib-strict</c> feature</title>
<body>

<p>
Many Makefiles assume that their libraries should go to <c>/usr/lib</c>, or
<c>$(prefix)/lib</c>. This assumption can cause a serious mess if <c>/usr/lib</c>
isn't a symlink to <c>/usr/lib64</c>. To find the bad packages, we have a Portage feature
called <b>multilib-strict</b>. It will prevent emerge from putting 64-bit libraries
into anything other than <c>(/usr)/lib64</c>.
</p>

<p>
<c>multilib-strict</c> currently doesn't check perl5, gcc, gcc-lib and eclipse-3,
this behaviour is controlled by the <c>MULTILIB_STRICT_EXEMPT</c> variable in
<c>make.profile</c>.
</p>
</body>

<subsubsection>
<title>How to fix ebuilds properly</title>
<body>

<p>
In most cases, default <c>econf</c> behaviour is sufficient, because it will
pass the correct <c>--libdir</c> option to <c>configure</c>.
</p>

<p>
Some packages provide really bad Makefiles which hard-code <c>/usr/lib</c>. Those
should be <c>sed</c> -ed or patched. Don't forget to let upstream know about your
modifications!
</p>

</body>
</subsubsection>
</subsection>

<subsection>
<title>Headers and multilib</title>
<body>

<p>
Most C/C++ programs need standard header files like <c>types.h</c>. Some of them
depend on architecture specific facts, e.g. <c>types.h</c> on the length
of machine words. To ensure that we can compile both 32-bit and 64-bit
applications and libraries, we treat <c>/usr/include/asm</c> a bit special.
</p>

<p>
This is what <c>/usr/include/asm/types.h</c> looks like on an AMD64 box:
</p>

<codesample lang="c">
/* Common header file autogenerated by create_ml_includes in multilib.eclass */
#ifdef __i386__
#include &lt;asm-i386/types.h&gt;
#endif /* __i386__ */

#ifdef __x86_64__
#include &lt;asm-x86_64/types.h&gt;
#endif /* __x86_64__ */
</codesample>

<p>
As you can see, this is just a wrapper that decides which file you need
depending on the parameter <c>-D</c> given to gcc. You'll probably run into
some troubles if you try to compile something by hand and forget to append
<c>-D__x86_64__</c> to your <c>CFLAGS</c>. Of course, this is
<b>not necessary</b> when using Portage. For an explanation, see the
<uri link="::archs/amd64/#The ABI variable"/> section.
</p>

</body>
</subsection>

<subsection>
<title>The ABI variable</title>
<body>

<p>
Whenever Portage builds something on amd64, it has to decide whether it should
be 32-bit or 64-bit. As stated in
<uri link="::archs/amd64/#Headers and multilib"/> the <c>__i386__</c> or
<c>__x86_64__</c> respectively, is needed in <c>CDEFINE</c>. Also, gcc has to
know what code it should produce, therefore <c>-m32</c> or <c>-m64</c> must be
appended to CFLAGS. This is done via <c>profile.bashrc</c>. All you need to do
if you want to build a package 32-bit is to set <c>ABI=x86</c>.
</p>

<p>
The details are shown in <c>make.defaults</c>:
</p>

<codesample lang="ebuild">
MULTILIB_ABIS="x86 amd64"
DEFAULT_ABI="amd64"

CFLAGS_amd64="-m64"
LDFLAGS_amd64="-m elf_x86_64"
CHOST_amd64="x86_64-pc-linux-gnu"
CDEFINE_amd64="__x86_64__"
LIBDIR_amd64="lib64"

CFLAGS_x86="-m32 -L/emul/linux/x86/lib -L/emul/linux/x86/usr/lib"
LDFLAGS_x86="-m elf_i386 -L/emul/linux/x86/lib -L/emul/linux/x86/usr/lib"
CHOST_x86="i686-pc-linux-gnu"
CDEFINE_x86="__i386__"
LIBDIR_x86="lib32"
</codesample>

</body>
</subsection>
</section>

<section>
<title>Porting notes</title>

<subsection>
<title>Machine word sizes</title>
<body>

<p>
On AMD64, some types differ in size from x86:
</p>

<table>
  <tr>
    <th>
      Type
    </th>
    <th>
      x86 (ILP32)
    </th>
    <th>
      amd64 (LP64)
    </th>
  </tr>
  <tr>
    <ti>
      <c>char</c>
    </ti>
    <ti>
      1 byte
    </ti>
    <ti>
      1 byte
    </ti>
  </tr>
  <tr>
    <ti>
      <c>short</c>
    </ti>
    <ti>
      2 bytes
    </ti>
    <ti>
      2 bytes
    </ti>
  </tr>
  <tr>
    <ti>
      <c>int</c>
    </ti>
    <ti>
      4 bytes
    </ti>
    <ti>
      4 bytes
    </ti>
  </tr>
  <tr>
    <ti>
      <c>long</c>
    </ti>
    <ti>
      <b>4 bytes</b>
    </ti>
    <ti>
      <b>8 bytes</b>
    </ti>
  </tr>
  <tr>
    <ti>
      <c>long long</c>
    </ti>
    <ti>
      8 bytes
    </ti>
    <ti>
      8 bytes
    </ti>
  </tr>
  <tr>
    <ti>
      <c>pointer</c>
    </ti>
    <ti>
      <b>4 bytes</b>
    </ti>
    <ti>
      <b>8 bytes</b>
    </ti>
  </tr>
  <tr>
    <ti>
      <c>float</c>
    </ti>
    <ti>
      4 bytes
    </ti>
    <ti>
      4 bytes
    </ti>
  </tr>
  <tr>
    <ti>
      <c>double</c>
    </ti>
    <ti>
      8 bytes
    </ti>
    <ti>
      8 bytes
    </ti>
  </tr>
  <tr>
    <ti>
      <c>long double</c>
    </ti>
    <ti>
      16 bytes
    </ti>
    <ti>
      16 bytes
    </ti>
  </tr>
</table>

<p>
If you need an exact amount of space, don't use these types but the <c>uXX</c> and
<c>sXX</c> ones provided by <c>types.h</c>, where XX is the number of bits you need.
Switching to a type that is the same on both arches is not suggested since it's
not a clean solution and might cause problems with other arches.
</p>

</body>
</subsection>

<subsection>
<title>Casts</title>
<body>

<p>
Many upstream developers assume that the length of a pointer is 4 bytes, which
can cause problems when programs do casts from <c>void *</c> to <c>int</c> and vice
versa. With GCC 3.4, this causes warnings, the compilation won't abort. If
you're lucky, your package works, but it's likely that you encounter
segmentation faults or strange behaviour. GCC 4.0 refuses to compile such code.
</p>

</body>
</subsection>
</section>

<section>
<title>Other resources</title>
<body>

<ul>
  <li>
    <uri link="https://wiki.gentoo.org/wiki/Project:AMD64">Gentoo/AMD64 Project</uri>
  </li>
  <li>
    <uri link="https://wiki.gentoo.org/wiki/AMD64/FAQ">Gentoo/Linux AMD64 FAQ</uri>
  </li>
  <li>
    <uri link="https://forums.gentoo.org/viewforum-f-46.html">Gentoo on AMD64 Forum</uri>
  </li>
</ul>

</body>
</section>
</chapter>
</devbook>
