<?xml version="1.0"?>
<guide self="general-concepts/dependencies/">
<chapter>
<title>Dependencies</title>

<body>

<p>
Automatic dependency resolution is one of the most useful features
provided by <c>emerge</c>.
</p>
</body>

<section>
<title>CHOST vs CBUILD</title>
<body>

<p>
In order to avoid ambiguity, we use the following terms to indicate different
systems when cross-compiling:
</p>

<dl>
  <dt>CBUILD</dt>
  <dd>
    The system on which the build is performed.  Dependencies that apply
    to the CBUILD system can be executed during build time.  When
    cross-compiling, they are not installed into the system being built.
  </dd>

  <dt>CHOST</dt>
  <dd>
    The system on which the package is going to be executed.  When
    cross-compiling, dependencies applying to CHOST can not be executed.
  </dd>
</dl>

<p>
When not cross-compiling, CBUILD and CHOST have the same value and both classes
of dependencies are merged.
</p>

</body>
</section>

<section>
<title>Build Dependencies</title>
<body>

<p>
Build dependencies are used to specify any dependencies that are required
to unpack, patch, compile, test or install the package (but see
<uri link="::general-concepts/dependencies#Implicit System Dependency"/> for
exemptions).
</p>

<p>
Starting with EAPI 7, build dependencies are split into two variables:
<c>BDEPEND</c> and <c>DEPEND</c>. <c>BDEPEND</c> specifies dependencies
applicable to CBUILD, i.e. programs that need to be executed during the build,
e.g. <c>virtual/pkgconfig</c>. <c>DEPEND</c> specifies dependencies for CHOST,
i.e. packages that need to be found on built system, e.g. libraries and headers.
</p>

<p>
In earlier EAPIs, all build dependencies are placed in <c>DEPEND</c>.
</p>

</body>
</section>

<section>
<title>Runtime Dependencies</title>
<body>

<p>
The <c>RDEPEND</c> ebuild variable should specify any dependencies which are
required at runtime. This includes libraries (when dynamically linked), any data
packages and (for interpreted languages) the relevant interpreter.
</p>

<p>
Note that when installing from a binary package, only <c>RDEPEND</c> will be
checked. It is therefore necessary to include items even if they are also listed
in <c>DEPEND</c>.
</p>

<p>
Items which are in <c>RDEPEND</c> but not <c>DEPEND</c> could <e>in theory</e> be merged
<e>after</e> the target package. Portage does not currently do this.
</p>

</body>
</section>

<section>
<title>Post-Merge Dependencies</title>
<body>

<p>
The <c>PDEPEND</c> variable specifies dependencies that should be
merged <e>after</e> the package, but which may be merged at any time,
if the former is not possible. This is sometimes used for plugins
that have a dependency upon the package being merged. Generally
<c>PDEPEND</c> should be avoided in favour of <c>RDEPEND</c> except
where this will create circular dependency chains.
</p>

</body>
</section>

<section>
<title>Implicit System Dependency</title>
<body>

<p>
All packages have an implicit compile-time and runtime dependency upon the
entire <c>@system</c> set. It is therefore not necessary, nor
advisable, to
specify dependencies upon toolchain packages like <c>gcc</c>, <c>libc</c> and
so on, except where specific versions or packages (for example, <c>glibc</c>
over <c>uclibc</c>) are required.  Note that this rule also needs consideration
for packages like <c>flex</c>, <c>zlib</c> and <c>libtool</c>, which aren't in
the <c>@system</c> set for every profile. For example, the embedded
profile doesn't have <c>zlib</c> in <c>@system</c>, the <c>libtool</c>
ABI might
change and break building order and <c>flex</c> might get removed from the
<c>@system</c> set in future.
</p>

<p>
However, packages which are included in the <c>@system</c> set, or are
dependencies of <c>@system</c> set packages, should generally include
a complete dependency list (excluding bootstrap packages). This makes
<c>emerge -e @system</c>
possible when installing from a stage 1 or stage 2 tarball.
</p>

</body>
</section>

<section>
<title>Basic Dependency Syntax</title>
<body>

<p>
A basic <c>DEPEND</c> specification might look like the following:
</p>

<codesample lang="ebuild">
DEPEND="dev-lang/ruby
	dev-ruby/ruby-gtk2
	dev-ruby/mysql-ruby"
</codesample>

<p>
Each <e>package dependency specification</e> is the full category and name of
a package. Dependency specifications are separated by arbitrary whitespace <d/>
convention is to have one specification per line for readability purposes.
When specifying names, the category part should be treated as mandatory.
</p>

</body>
</section>

<section>
<title>Version Dependencies</title>
<body>

<p>
Sometimes a particular version of a package is needed. Where this is known, it
should be specified. A simple example:
</p>

<codesample lang="ebuild">
DEPEND=">=dev-libs/openssl-0.9.7d"
</codesample>

<p>
This states that at least version 0.9.7d of <c>openssl</c> is required.
</p>
</body>

<subsection>
<title>Version Specifiers</title>
<body>

<p>
Available version specifiers are:
</p>

<table>
  <tr>
    <th>Specifier</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <ti><c>>=app-misc/foo-1.23</c></ti>
    <ti>Version 1.23 or later is required.</ti>
  </tr>
  <tr>
    <ti><c>>app-misc/foo-1.23</c></ti>
    <ti>A version strictly later than 1.23 is required.</ti>
  </tr>
  <tr>
    <ti><c>~app-misc/foo-1.23</c></ti>
    <ti>Version 1.23 (or any <c>1.23-r*</c>) is required.</ti>
  </tr>
  <tr>
    <ti><c>=app-misc/foo-1.23</c></ti>
    <ti>
      Exactly version 1.23 is required. If at all possible,
      use the <c>~</c> form to simplify revision bumps.
    </ti>
  </tr>
  <tr>
    <ti><c>&lt;=app-misc/foo-1.23</c></ti>
    <ti>Version 1.23 or older is required.</ti>
  </tr>
  <tr>
    <ti><c>&lt;app-misc/foo-1.23</c></ti>
    <ti>A version strictly before 1.23 is required.</ti>
  </tr>
</table>

</body>
</subsection>

<subsection>
<title>Ranged Dependencies</title>
<body>

<p>
To specify "version 2.x (not 1.x or 3.x)" of a package, it is necessary to use
the asterisk postfix. This is most commonly seen in situations like:
</p>

<codesample lang="ebuild">
DEPEND="gtk? ( =x11-libs/gtk+-2* )"
</codesample>

<p>
Note that the equals sign is mandatory, and that there is no dot before the
asterisk. Also note that when selecting all versions in a specific
<c>SLOT</c>, <c>SLOT</c> dependencies should be used (see below).
</p>

</body>
</subsection>

<subsection>
<title>Blockers</title>
<body>

<p>
When two packages (package slots, versions) can not be installed
simultaneously, blockers can be used to expose such a conflict
to the package manager.
</p>

<p>
There are two kinds of blockers: <e>weak blockers</e> and <e>strong
blockers</e>.
</p>

<p>
A weak blocker is defined using the following syntax:
</p>

<codesample lang="ebuild">
RDEPEND="!app-misc/foo"
</codesample>

<p>
The package manager will try to resolve this conflict automatically.
The package blocked by a weak blocker can be uninstalled <e>after</e>
installing the package blocking it. However, it exempts the common
files from file collision checks. Weak blockers are usually used
to solve file collisions between packages and are meaningful only
in <c>RDEPEND</c>.
</p>

<p>
More specifically, installation of the newer package may overwrite any
colliding files that belong to the older package that is explicitly blocked.
When such file collisions occur, the colliding files cease to belong to the
older package, and they remain installed after the older package is eventually
uninstalled. The older package is uninstalled only after any newer blocking
packages have been merged on top of it.
</p>

<warning>
Weak blockers that are pure <c>DEPEND</c> <e>do not work correctly</e>.
While Portage seemingly queues the package for removal, it <e>does not</e>
exempt their contents from file collision checks. Always include your
weak blockers in <c>RDEPEND</c>!
</warning>

<p>
If it is strictly necessary to resolve the blocker before the package
is built (installed), a strong blocker must be used instead. In this case,
temporary simultaneous installation of the conflicting packages is not allowed.
Strong blockers are expressed using the following syntax:
</p>

<codesample lang="ebuild">
RDEPEND="!!app-misc/foo"
</codesample>

<p>
Strong blockers apply accordingly to the dependency type defining them.
Blockers defined in <c>RDEPEND</c> are enforced as long as the package
is installed (but do not prevent building binary packages). Blockers
defined purely in <c>DEPEND</c> are enforced only for building
the package from source, and may not apply once the package is installed
or when it is installed from a binary package.
</p>

<note>
If both weak and strong blockers match a given package, the strong blocker
takes precedence.
</note>

<p>
Specific versions can also be blocked:
</p>

<codesample lang="ebuild">
RDEPEND="!&lt;app-misc/foo-1.3"
</codesample>

<p>
Blockers can be optional based upon <c>USE</c> flags as per normal
dependencies.
</p>

<p>
Blockers added to older ebuilds should not be expected to be retroactive.  If
the user already has the ebuild installed, any changes to the ebuild should not
be expected to make any difference.  This means that you should add the
blockers to whichever ebuild is the newest (even if it means that logically it
would seem backwards).  For example, certain versions of portage don't like
some versions of bash, but the blocker was put into bash because that was the
newer package that caused the issues.
</p>

</body>
</subsection>
</section>

<section>
<title>SLOT Dependencies</title>
<body>

<p>
To depend on a specific <c>SLOT</c>, <c>:SLOT</c> should be appended to
the package name, where 'SLOT' is the <c>SLOT</c> of the package wanted:
</p>

<codesample lang="ebuild">
DEPEND="qt3? ( x11-libs/qt:3 )
	gtk? ( x11-libs/gtk+:2 )
</codesample>

<p>
To depend on a specific version or version-range within a SLOT we use:
</p>

<codesample lang="ebuild">
DEPEND="qt3? ( ~x11-libs/qt-3.3.8:3 )
	gtk? ( >=x11-libs/gtk+-2.24.9:2 )
</codesample>
</body>

<subsection>
<title>Slot Operators</title>
<body>

<p>
In <c>EAPI=5</c> and higher, you can use slot operators appended to the package
name to declare whether or not your package should be rebuilt after the versions
satisfying its runtime dependencies are updated to versions with a different slot
or <uri link="::general-concepts/slotting#Sub-Slots">sub-slot</uri>:
</p>

<ul>
  <li><c>:=</c> means that any slot is acceptable, and that your package should be
  rebuilt if the version best matching the runtime dependency is updated to a
  version with a different slot or subslot;</li>
  <li><c>:*</c> means that any slot is acceptable, and explicitly declares that
  changes in the slot or sub-slot can be ignored;</li>
  <li><c>:SLOT=</c> means that only the 'SLOT' slot is acceptable, and that your
  package should be rebuilt if the version matching the runtime dependency is
  updated to another version with this slot but with a different subslot;</li>
  <li><c>:SLOT</c> means that only the 'SLOT' slot is acceptable, and that changes
  in the sub-slot can be ignored (like in previous EAPIs).</li>
  <li><c>:SLOT/SUBSLOT</c> means a dependency on a specific slot and sub-slot pair,
  which can be useful for packages installing pre-built binaries that require a
  library with a particular soname version corresponding to the sub-slot.</li>
</ul>

<p>
For example:
</p>

<codesample lang="ebuild">
RDEPEND="media-libs/cogl:1.0=
	gnutls? ( &gt;=net-libs/gnutls-2.8:= )"
</codesample>

</body>
</subsection>
</section>

<section>
<title>USE-Conditional Dependencies</title>
<body>

<p>
To depend upon a certain package if and only if a given <c>USE</c> flag is set:
</p>

<codesample lang="ebuild">
DEPEND="perl? ( dev-lang/perl )
	ruby? ( &gt;=dev-lang/ruby-1.8 )
	python? ( dev-lang/python )"
</codesample>

<p>
It is also possible to depend upon a certain package if a given <c>USE</c> flag is
<e>not</e> set:
</p>

<codesample lang="ebuild">
RDEPEND="!crypt? ( net-misc/netkit-rsh )"
</codesample>

<p>
This should <b>not</b> be used for disabling a certain <c>USE</c> flag on a given
architecture. In order to do this, the architecture team should add the <c>USE</c>
flag to their <c>use.mask</c> file in the <c>profiles/arch</c>
directory of the Gentoo repository.
</p>

<p>
This can be nested:
</p>

<codesample lang="ebuild">
DEPEND="!build? (
	gcj? (
		gtk? (
			x11-libs/libXt
			x11-libs/libX11
			x11-libs/libXtst
			x11-proto/xproto
			x11-proto/xextproto
			>=x11-libs/gtk+-2.2
			x11-libs/pango
		)
		>=media-libs/libart_lgpl-2.1
	)
	>=sys-libs/ncurses-5.2-r2
	nls? ( sys-devel/gettext )
)"
</codesample>

</body>
</section>

<section>
<title>Any of Many Dependencies</title>
<body>

<p>
To depend on either <c>foo</c> or <c>bar</c>:
</p>

<codesample lang="ebuild">
DEPEND="|| ( app-misc/foo app-misc/bar )"
</codesample>

<p>
To depend on either <c>foo</c> or <c>bar</c> if the <c>baz</c> <c>USE</c> flag is set:
</p>

<codesample lang="ebuild">
DEPEND="baz? ( || ( app-misc/foo app-misc/bar ) )"
</codesample>
</body>

<subsection>
<title>Any of Many Versus USE</title>
<body>

<p>
Say <c>fnord</c> can be built against either <c>foo</c> or <c>bar</c>. Then a <c>USE</c>
flag is not necessary if and only if all of the following hold:
</p>

<ul>
  <li>
    <c>fnord</c> is merged on a system which has <c>foo</c> and not <c>bar</c> installed.
    <c>foo</c> is then unmerged, and <c>bar</c> is installed. <c>fnord</c> must continue to
    work correctly.
  </li>
  <li>
    A binary package of <c>fnord</c> made on a system with <c>foo</c> and not <c>bar</c>
    can be taken and installed on a system with <c>bar</c> and not <c>foo</c>.
  </li>
</ul>

</body>
</subsection>
</section>

<section>
<title>Built with USE Dependencies</title>
<body>

<p>
Available specifiers are:
</p>

<table>
  <tr>
    <th>Specifier</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <ti><c>app-misc/foo[bar]</c></ti>
    <ti>foo must have bar enabled.</ti>
  </tr>
  <tr>
    <ti><c>app-misc/foo[bar,baz]</c></ti>
    <ti>foo must have both bar and baz enabled.</ti>
  </tr>
  <tr>
    <ti><c>app-misc/foo[-bar,baz]</c></ti>
    <ti>foo must have bar disabled and baz enabled.</ti>
  </tr>
</table>

<p>
There are also shortcuts for conditional situations:
</p>

<table>
  <tr>
    <th>Compact form</th>
    <th>Equivalent expanded form</th>
  </tr>
  <tr>
    <ti><c>app-misc/foo[bar?]</c></ti>
    <ti><c>bar? ( app-misc/foo[bar] ) !bar? ( app-misc/foo )</c></ti>
  </tr>
  <tr>
    <ti><c>app-misc/foo[!bar?]</c></ti>
    <ti><c>bar? ( app-misc/foo ) !bar? ( app-misc/foo[-bar] )</c></ti>
  </tr>
  <tr>
    <ti><c>app-misc/foo[bar=]</c></ti>
    <ti><c>bar? ( app-misc/foo[bar] ) !bar? ( app-misc/foo[-bar] )</c></ti>
  </tr>
  <tr>
    <ti><c>app-misc/foo[!bar=]</c></ti>
    <ti><c>bar? ( app-misc/foo[-bar] ) !bar? ( app-misc/foo[bar] )</c></ti>
  </tr>
</table>
</body>

<subsection>
<title>Use dependency defaults</title>
<body>

<p>
If a dependency is introducing or removing a <c>USE</c> flag in new versions, a use
dependency default may be used. Appending a <c>(+)</c> or <c>(-)</c> suffix will indicate
whether the absence of the flag from a particular version should indicate its
presence or absence.
</p>
<p>
<c>>=dev-libs/boost-1.48[threads(+)]</c> will treat all versions without <c>threads</c> as having it set.
</p>

</body>
</subsection>
</section>

<section>
<title>Test Dependencies</title>
<body>

<p>
Packages often have optional dependencies that are needed only when running
tests. These should be specified in DEPEND behind a USE flag. Often, the
'test' USE flag is used for this purpose.
</p>

<p>
Since testing will likely fail when test dependencies are not installed, the
test phase should be disabled in this case. This may be accomplished via USE
conditionals in the RESTRICT variable.
</p>

<p>
If other optional features must be enabled/disabled when testing, REQUIRED_USE
may be set to express this.
</p>

<codesample lang="ebuild">
# Define some USE flags
IUSE="debug test"

# Require debug support when tests are enabled
REQUIRED_USE="test? ( debug )"

# Disable test phase when test USE flag is disabled
RESTRICT="!test? ( test )"

# Running tests requires 'foo' to be installed
DEPEND="test? ( dev-util/foo )"
</codesample>

</body>
</section>
</chapter>
</guide>
